<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversor OCR de PDF - Processos Digitalizados</title>
    
    <!-- Vue 3 e Vuetify -->
    <link href="https://cdn.jsdelivr.net/npm/vuetify@3.4.0/dist/vuetify.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.x/css/materialdesignicons.min.css" rel="stylesheet">
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- Tesseract.js para OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
    
    <!-- jsPDF para gerar PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        #app {
            font-family: 'Roboto', sans-serif;
        }
        
        .pdf-preview {
            max-width: 100%;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .canvas-container {
            position: relative;
            margin: 10px 0;
        }
        
        .page-canvas {
            width: 100%;
            height: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .ocr-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(33, 150, 243, 0.1) 10px,
                rgba(33, 150, 243, 0.1) 20px
            );
        }
        
        .extracted-text {
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
        }
        
        .drop-zone {
            border: 2px dashed #1976d2;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s;
            background: linear-gradient(45deg, #f3f4f6 25%, transparent 25%, transparent 75%, #f3f4f6 75%, #f3f4f6),
                        linear-gradient(45deg, #f3f4f6 25%, transparent 25%, transparent 75%, #f3f4f6 75%, #f3f4f6);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }
        
        .drop-zone.dragover {
            background-color: #e3f2fd;
            border-color: #2196f3;
        }
        
        .confidence-chip {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .confidence-high {
            background-color: #4caf50;
            color: white;
        }
        
        .confidence-medium {
            background-color: #ff9800;
            color: white;
        }
        
        .confidence-low {
            background-color: #f44336;
            color: white;
        }

        /* Performance Metrics Styles */
        .performance-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 500;
            margin: 4px;
        }

        .performance-metric {
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 8px;
            margin: 8px 0;
            border-left: 4px solid #2196f3;
        }

        .metric-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .metric-value {
            font-size: 20px;
            font-weight: bold;
            color: #2196f3;
        }

        .resource-chip {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
            margin: 2px;
        }
    </style>
</head>
<body>
    <div id="app">
        <v-app>
            <v-app-bar color="primary" dense>
                <v-app-bar-title>
                    <v-icon left>mdi-file-pdf-box</v-icon>
                    Conversor OCR Avan√ßado para Processos Digitalizados
                </v-app-bar-title>
            </v-app-bar>
            
            <v-main>
                <v-container>
                    <!-- √Årea de Upload -->
                    <v-row v-if="!pdfFile">
                        <v-col cols="12">
                            <v-card>
                                <v-card-title>
                                    <v-icon left>mdi-cloud-upload</v-icon>
                                    Upload do PDF Digitalizado
                                </v-card-title>
                                <v-card-text>
                                    <div 
                                        class="drop-zone"
                                        @dragover.prevent="dragover = true"
                                        @dragleave.prevent="dragover = false"
                                        @drop.prevent="handleDrop"
                                        :class="{ 'dragover': dragover }"
                                    >
                                        <v-icon size="64" color="primary">mdi-file-upload</v-icon>
                                        <h3 class="mt-4">Arraste o arquivo PDF aqui</h3>
                                        <p class="text-grey">ou</p>
                                        <v-btn color="primary" @click="$refs.fileInput.click()">
                                            <v-icon left>mdi-folder-open</v-icon>
                                            Selecionar Arquivo
                                        </v-btn>
                                        <input
                                            ref="fileInput"
                                            type="file"
                                            accept=".pdf"
                                            style="display: none"
                                            @change="handleFileSelect"
                                        >
                                    </div>
                                </v-card-text>
                            </v-card>
                        </v-col>
                    </v-row>
                    
                    <!-- Configura√ß√µes de OCR -->
                    <v-row v-if="pdfFile && !processing">
                        <v-col cols="12">
                            <v-card>
                                <v-card-title>
                                    <v-icon left>mdi-cog</v-icon>
                                    Configura√ß√µes de OCR
                                </v-card-title>
                                <v-card-text>
                                    <v-row>
                                        <v-col cols="12" md="4">
                                            <v-select
                                                v-model="ocrLanguage"
                                                :items="languages"
                                                label="Idioma do Documento"
                                                item-title="text"
                                                item-value="value"
                                                prepend-icon="mdi-translate"
                                            ></v-select>
                                        </v-col>
                                        <v-col cols="12" md="4">
                                            <v-select
                                                v-model="ocrMode"
                                                :items="ocrModes"
                                                label="Modo de OCR"
                                                item-title="text"
                                                item-value="value"
                                                prepend-icon="mdi-eye-settings"
                                            ></v-select>
                                        </v-col>
                                        <v-col cols="12" md="4">
                                            <v-select
                                                v-model="outputFormat"
                                                :items="outputFormats"
                                                label="Formato de Sa√≠da"
                                                item-title="text"
                                                item-value="value"
                                                prepend-icon="mdi-file-export"
                                            ></v-select>
                                        </v-col>
                                    </v-row>
                                    <v-row>
                                        <v-col cols="12" md="6">
                                            <v-switch
                                                v-model="enhanceImage"
                                                label="Melhorar qualidade da imagem antes do OCR"
                                                color="primary"
                                            ></v-switch>
                                        </v-col>
                                        <v-col cols="12" md="6">
                                            <v-switch
                                                v-model="preserveLayout"
                                                label="Preservar layout original"
                                                color="primary"
                                            ></v-switch>
                                        </v-col>
                                    </v-row>
                                </v-card-text>
                            </v-card>
                        </v-col>
                    </v-row>
                    
                    <!-- Preview e Processamento -->
                    <v-row v-if="pdfFile">
                        <v-col cols="12" md="6">
                            <v-card>
                                <v-card-title>
                                    <v-icon left>mdi-file-eye</v-icon>
                                    Preview do PDF Original
                                    <v-spacer></v-spacer>
                                    <v-chip small>
                                        {{ totalPages }} p√°gina(s)
                                    </v-chip>
                                </v-card-title>
                                <v-card-text>
                                    <div v-if="pdfDocument" class="canvas-container">
                                        <canvas ref="pdfCanvas" class="page-canvas"></canvas>
                                        <div v-if="processing" class="ocr-overlay"></div>
                                    </div>
                                    <v-pagination
                                        v-model="currentPage"
                                        :length="totalPages"
                                        :total-visible="5"
                                        class="mt-4"
                                        @update:model-value="renderPage"
                                    ></v-pagination>
                                </v-card-text>
                                <v-card-actions>
                                    <v-btn 
                                        color="primary" 
                                        @click="startOCR"
                                        :loading="processing"
                                        :disabled="processing"
                                        block
                                    >
                                        <v-icon left>mdi-text-recognition</v-icon>
                                        {{ processing ? 'Processando...' : 'Iniciar Convers√£o OCR' }}
                                    </v-btn>
                                </v-card-actions>
                            </v-card>
                        </v-col>
                        
                        <v-col cols="12" md="6">
                            <v-card>
                                <v-card-title>
                                    <v-icon left>mdi-text-box-outline</v-icon>
                                    Texto Extra√≠do
                                    <v-spacer></v-spacer>
                                    <span v-if="averageConfidence > 0" class="confidence-chip" :class="confidenceClass">
                                        Confian√ßa: {{ averageConfidence.toFixed(1) }}%
                                    </span>
                                </v-card-title>
                                <v-card-text>
                                    <div v-if="extractedText" class="extracted-text">
                                        {{ extractedText }}
                                    </div>
                                    <v-alert v-else type="info" outlined>
                                        O texto extra√≠do aparecer√° aqui ap√≥s o processamento
                                    </v-alert>
                                </v-card-text>
                                <v-card-actions v-if="extractedText">
                                    <v-btn 
                                        color="success" 
                                        @click="downloadSearchablePDF"
                                        :disabled="!ocrCompleted"
                                    >
                                        <v-icon left>mdi-download</v-icon>
                                        Baixar PDF Pesquis√°vel
                                    </v-btn>
                                    <v-btn 
                                        color="info" 
                                        @click="downloadText"
                                        :disabled="!ocrCompleted"
                                    >
                                        <v-icon left>mdi-file-document-outline</v-icon>
                                        Baixar Texto
                                    </v-btn>
                                </v-card-actions>
                            </v-card>
                        </v-col>
                    </v-row>
                    
                    <!-- Progress -->
                    <v-row v-if="processing">
                        <v-col cols="12">
                            <v-card>
                                <v-card-text>
                                    <v-progress-linear
                                        v-model="progress"
                                        color="primary"
                                        height="25"
                                        striped
                                    >
                                        <template v-slot:default="{ value }">
                                            <strong>{{ Math.ceil(value) }}%</strong>
                                        </template>
                                    </v-progress-linear>
                                    <p class="mt-3 text-center">
                                        {{ progressMessage }}
                                    </p>
                                </v-card-text>
                            </v-card>
                        </v-col>
                    </v-row>
                    
                    <!-- Estat√≠sticas -->
                    <v-row v-if="ocrCompleted">
                        <v-col cols="12">
                            <v-card>
                                <v-card-title>
                                    <v-icon left>mdi-chart-box</v-icon>
                                    Estat√≠sticas do Processamento
                                </v-card-title>
                                <v-card-text>
                                    <v-row>
                                        <v-col cols="6" md="3">
                                            <v-card outlined>
                                                <v-card-text class="text-center">
                                                    <div class="text-h4">{{ totalPages }}</div>
                                                    <div>P√°ginas Processadas</div>
                                                </v-card-text>
                                            </v-card>
                                        </v-col>
                                        <v-col cols="6" md="3">
                                            <v-card outlined>
                                                <v-card-text class="text-center">
                                                    <div class="text-h4">{{ wordCount }}</div>
                                                    <div>Palavras Extra√≠das</div>
                                                </v-card-text>
                                            </v-card>
                                        </v-col>
                                        <v-col cols="6" md="3">
                                            <v-card outlined>
                                                <v-card-text class="text-center">
                                                    <div class="text-h4">{{ processingTime }}s</div>
                                                    <div>Tempo de Processamento</div>
                                                </v-card-text>
                                            </v-card>
                                        </v-col>
                                        <v-col cols="6" md="3">
                                            <v-card outlined>
                                                <v-card-text class="text-center">
                                                    <div class="text-h4">{{ averageConfidence.toFixed(1) }}%</div>
                                                    <div>Confian√ßa M√©dia</div>
                                                </v-card-text>
                                            </v-card>
                                        </v-col>
                                    </v-row>

                                    <!-- FASE 3: M√©tricas de Performance -->
                                    <v-divider class="my-4"></v-divider>
                                    <div class="text-subtitle-1 mb-3">
                                        <v-icon left>mdi-speedometer</v-icon>
                                        M√©tricas de Performance
                                    </div>
                                    <v-row>
                                        <v-col cols="12" md="4">
                                            <div class="performance-metric">
                                                <div class="metric-label">Velocidade de Processamento</div>
                                                <div class="metric-value">{{ performanceMetrics.pagesPerSecond }} p√°g/s</div>
                                            </div>
                                        </v-col>
                                        <v-col cols="12" md="4">
                                            <div class="performance-metric">
                                                <div class="metric-label">Workers Utilizados</div>
                                                <div class="metric-value">{{ systemResources.workers }} workers</div>
                                            </div>
                                        </v-col>
                                        <v-col cols="12" md="4">
                                            <div class="performance-metric">
                                                <div class="metric-label">Modo de Performance</div>
                                                <div class="metric-value" style="font-size: 16px;">{{ systemResources.mode }}</div>
                                            </div>
                                        </v-col>
                                    </v-row>

                                    <!-- Recursos do Sistema -->
                                    <div class="mt-4">
                                        <span class="resource-chip">
                                            <v-icon small left>mdi-cpu-64-bit</v-icon>
                                            {{ systemResources.cpuCores }} CPU Cores
                                        </span>
                                        <span class="resource-chip">
                                            <v-icon small left>mdi-memory</v-icon>
                                            {{ systemResources.memoryGB }} GB RAM
                                        </span>
                                        <span class="resource-chip">
                                            <v-icon small left>mdi-flash</v-icon>
                                            WebAssembly SIMD
                                        </span>
                                        <span class="resource-chip">
                                            <v-icon small left>mdi-cached</v-icon>
                                            Cache Ativo
                                        </span>
                                    </div>
                                </v-card-text>
                            </v-card>
                        </v-col>
                    </v-row>

                    <!-- Bot√£o de Reset -->
                    <v-row v-if="pdfFile">
                        <v-col cols="12">
                            <v-btn 
                                color="error" 
                                @click="resetApp"
                                variant="outlined"
                                block
                            >
                                <v-icon left>mdi-restart</v-icon>
                                Processar Novo Arquivo
                            </v-btn>
                        </v-col>
                    </v-row>
                </v-container>
            </v-main>
            
            <!-- Snackbar para mensagens -->
            <v-snackbar v-model="snackbar" :color="snackbarColor" :timeout="3000">
                {{ snackbarMessage }}
                <template v-slot:actions>
                    <v-btn variant="text" @click="snackbar = false">Fechar</v-btn>
                </template>
            </v-snackbar>
        </v-app>
    </div>
    
    <!-- Vue 3 e Vuetify -->
    <script src="https://unpkg.com/vue@3.4.0/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@3.4.0/dist/vuetify.min.js"></script>
    
    <script>
        const { createApp } = Vue;
        const { createVuetify } = Vuetify;
        
        // Configurar PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        const vuetify = createVuetify({
            theme: {
                themes: {
                    light: {
                        colors: {
                            primary: '#1976D2',
                            secondary: '#424242',
                            accent: '#82B1FF',
                            error: '#FF5252',
                            info: '#2196F3',
                            success: '#4CAF50',
                            warning: '#FFC107'
                        }
                    }
                }
            }
        });
        
        createApp({
            data() {
                return {
                    // Arquivo PDF
                    pdfFile: null,
                    pdfDocument: null,
                    currentPage: 1,
                    totalPages: 0,
                    currentPageCanvas: null,
                    
                    // Configura√ß√µes OCR
                    ocrLanguage: 'por',
                    ocrMode: 'accurate',
                    outputFormat: 'searchable_pdf',
                    enhanceImage: true,
                    preserveLayout: true,
                    
                    // Estado do processamento
                    processing: false,
                    progress: 0,
                    progressMessage: '',
                    ocrCompleted: false,

                    // Resultados
                    extractedText: '',
                    extractedPages: [],
                    averageConfidence: 0,
                    wordCount: 0,
                    processingTime: 0,

                    // Performance e recursos
                    systemResources: {
                        cpuCores: 4,
                        workers: 4,
                        memoryGB: 4,
                        mode: 'auto'
                    },
                    performanceMetrics: {
                        pagesProcessed: 0,
                        pagesPerSecond: 0,
                        estimatedTimeRemaining: 0
                    },
                    
                    // UI
                    dragover: false,
                    snackbar: false,
                    snackbarMessage: '',
                    snackbarColor: 'success',
                    
                    // Op√ß√µes
                    languages: [
                        { value: 'por', text: 'Portugu√™s' },
                        { value: 'eng', text: 'Ingl√™s' },
                        { value: 'por+eng', text: 'Portugu√™s + Ingl√™s' }
                    ],
                    ocrModes: [
                        { value: 'fast', text: 'R√°pido (menor precis√£o)' },
                        { value: 'accurate', text: 'Preciso (recomendado)' },
                        { value: 'best', text: 'M√°xima Qualidade (mais lento)' }
                    ],
                    outputFormats: [
                        { value: 'searchable_pdf', text: 'PDF Pesquis√°vel' },
                        { value: 'text', text: 'Apenas Texto' },
                        { value: 'both', text: 'PDF + Texto' }
                    ]
                };
            },
            
            computed: {
                confidenceClass() {
                    if (this.averageConfidence >= 85) return 'confidence-high';
                    if (this.averageConfidence >= 70) return 'confidence-medium';
                    return 'confidence-low';
                }
            },
            
            methods: {
                handleDrop(e) {
                    this.dragover = false;
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && files[0].type === 'application/pdf') {
                        this.loadPDF(files[0]);
                    }
                },
                
                handleFileSelect(e) {
                    const file = e.target.files[0];
                    if (file && file.type === 'application/pdf') {
                        this.loadPDF(file);
                    }
                },
                
                async loadPDF(file) {
                    this.pdfFile = file;

                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const typedArray = new Uint8Array(arrayBuffer);

                        const loadingTask = pdfjsLib.getDocument({data: typedArray});
                        const pdfDoc = await loadingTask.promise;

                        // Use markRaw para prevenir que Vue torne o PDF reativo
                        // Isso evita problemas com membros privados do PDF.js
                        this.pdfDocument = Vue.markRaw(pdfDoc);

                        this.totalPages = this.pdfDocument.numPages;
                        this.currentPage = 1;

                        // Aguarda Vue renderizar o canvas no DOM
                        await this.$nextTick();

                        await this.renderPage(1);

                        this.showMessage('PDF carregado com sucesso!', 'success');
                    } catch (error) {
                        console.error('PDF loading error details:', error);
                        this.showMessage('Erro ao carregar PDF: ' + error.message, 'error');
                    }
                },
                
                async renderPage(pageNum) {
                    if (!this.pdfDocument) return;
                    
                    const page = await this.pdfDocument.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.5 });
                    
                    const canvas = this.$refs.pdfCanvas;
                    const context = canvas.getContext('2d');
                    
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    this.currentPageCanvas = canvas;
                },

                // FASE 1: Detectar recursos do sistema
                detectSystemResources() {
                    const cpuCores = navigator.hardwareConcurrency || 4;
                    const memoryGB = navigator.deviceMemory || 4;

                    // Ajustar n√∫mero de workers baseado nos recursos
                    let workers, mode;

                    if (cpuCores >= 8 && memoryGB >= 8) {
                        workers = Math.min(cpuCores, 8); // M√°ximo de 8 workers
                        mode = 'high-performance';
                    } else if (cpuCores >= 4 && memoryGB >= 4) {
                        workers = 4;
                        mode = 'balanced';
                    } else {
                        workers = 2;
                        mode = 'low-resource';
                    }

                    this.systemResources = {
                        cpuCores,
                        workers,
                        memoryGB,
                        mode
                    };

                    console.log('üñ•Ô∏è Recursos detectados:', this.systemResources);
                    return this.systemResources;
                },

                // FASE 2: Pr√©-processamento otimizado com OffscreenCanvas
                async enhanceImageOptimized(canvas) {
                    if (!this.enhanceImage) return canvas;

                    try {
                        // Usar OffscreenCanvas se dispon√≠vel (mais r√°pido)
                        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
                        const ctx = offscreen.getContext('2d', {
                            willReadFrequently: false,
                            desynchronized: true
                        });

                        // Aplicar filtros usando GPU
                        ctx.filter = 'contrast(1.5) brightness(1.1) grayscale(1)';
                        ctx.drawImage(canvas, 0, 0);

                        return offscreen;
                    } catch (e) {
                        // Fallback para m√©todo tradicional
                        const context = canvas.getContext('2d');
                        this.enhanceImageQuality(context, canvas.width, canvas.height);
                        return canvas;
                    }
                },

                // FASE 1 & 2: Renderizar p√°ginas com melhorias de qualidade
                async renderPagesForOCR() {
                    const pages = [];
                    let nativeTextPages = 0;

                    this.progressMessage = 'Analisando p√°ginas...';

                    for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
                        // MELHORIA 1: Verificar se h√° texto nativo (evita OCR!)
                        const nativeText = await this.checkNativeText(pageNum);

                        if (nativeText) {
                            // P√°gina tem texto nativo, n√£o precisa OCR!
                            pages.push({
                                pageNum,
                                canvas: null,
                                nativeText: nativeText,
                                skipOCR: true
                            });
                            nativeTextPages++;
                            this.progress = (pageNum / this.totalPages) * 20;
                            continue;
                        }

                        // Precisa fazer OCR, renderizar a p√°gina
                        const page = await this.pdfDocument.getPage(pageNum);
                        const viewport = page.getViewport({ scale: 2 });

                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        await page.render({
                            canvasContext: context,
                            viewport: viewport
                        }).promise;

                        // MELHORIA 7: Aplicar pr√©-processamento AVAN√áADO
                        const enhancedCanvas = await this.enhanceImageAdvanced(canvas);

                        pages.push({
                            pageNum,
                            canvas: enhancedCanvas,
                            skipOCR: false
                        });

                        this.progress = (pageNum / this.totalPages) * 20; // 20% para renderiza√ß√£o
                    }

                    if (nativeTextPages > 0) {
                        console.log(`‚úÖ ${nativeTextPages} p√°ginas com texto nativo detectadas (OCR pulado!)`);
                    }

                    return pages;
                },

                // FASE 1, 2 & 3: OCR Paralelo Otimizado com M√∫ltiplos Workers
                async startOCR() {
                    this.processing = true;
                    this.progress = 0;
                    this.extractedPages = [];
                    this.extractedText = '';
                    this.performanceMetrics.pagesProcessed = 0;
                    const startTime = Date.now();

                    try {
                        // FASE 1: Detectar recursos do sistema
                        const resources = this.detectSystemResources();
                        this.showMessage(`üñ•Ô∏è Usando ${resources.workers} workers (${resources.mode})`, 'info');

                        // FASE 2: Verificar cache
                        const cacheKey = `ocr-${this.pdfFile.name}-${this.ocrLanguage}-${this.ocrMode}`;
                        const cached = this.loadFromCache(cacheKey);
                        if (cached) {
                            this.extractedPages = cached.pages;
                            this.compileResults();
                            this.ocrCompleted = true;
                            this.processing = false;
                            this.progress = 100;
                            this.showMessage('‚úÖ Resultado carregado do cache!', 'success');
                            return;
                        }

                        // FASE 1: Renderizar todas as p√°ginas
                        const pages = await this.renderPagesForOCR();

                        // FASE 1: Criar Scheduler com m√∫ltiplos workers
                        this.progressMessage = `Inicializando ${resources.workers} workers...`;
                        const scheduler = Tesseract.createScheduler();
                        const workers = [];

                        // FASE 1: Criar pool de workers com SIMD habilitado
                        for (let i = 0; i < resources.workers; i++) {
                            const worker = await Tesseract.createWorker(this.ocrLanguage, 1, {
                                // FASE 1: Habilitar SIMD para melhor performance
                                corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@v4.0.4/tesseract-core-simd.wasm.js',
                                logger: (m) => {
                                    if (m.status === 'recognizing text') {
                                        const baseProgress = 20 + ((this.performanceMetrics.pagesProcessed / this.totalPages) * 80);
                                        this.progress = baseProgress;
                                    }
                                }
                            });

                            // MELHORIA 6: Usar par√¢metros otimizados por modo
                            await worker.setParameters(this.getOptimizedTesseractParams());
                            scheduler.addWorker(worker);
                            workers.push(worker);
                        }

                        // FASE 3: M√©tricas de performance
                        let pagesProcessed = 0;
                        const updateMetrics = () => {
                            pagesProcessed++;
                            this.performanceMetrics.pagesProcessed = pagesProcessed;
                            const elapsed = (Date.now() - startTime) / 1000;
                            this.performanceMetrics.pagesPerSecond = (pagesProcessed / elapsed).toFixed(2);
                            const remaining = this.totalPages - pagesProcessed;
                            this.performanceMetrics.estimatedTimeRemaining = (remaining / this.performanceMetrics.pagesPerSecond).toFixed(0);

                            this.progressMessage = `Processando: ${pagesProcessed}/${this.totalPages} p√°ginas (${this.performanceMetrics.pagesPerSecond} p√°g/s)`;
                        };

                        // MELHORIA 1 & FASE 1: Processar p√°ginas (com texto nativo ou OCR)
                        const jobs = pages.map(({ pageNum, canvas, nativeText, skipOCR }) => {
                            if (skipOCR && nativeText) {
                                // P√°gina tem texto nativo, retornar direto!
                                updateMetrics();
                                return Promise.resolve({
                                    pageNum,
                                    text: nativeText,
                                    confidence: 100,
                                    native: true
                                });
                            }

                            // Processar com OCR em paralelo
                            return scheduler.addJob('recognize', canvas).then(result => {
                                updateMetrics();
                                // MELHORIA 5: Aplicar p√≥s-processamento
                                const processedText = this.postProcessText(result.data.text);
                                return {
                                    pageNum,
                                    text: processedText,
                                    confidence: result.data.confidence,
                                    native: false
                                };
                            });
                        });

                        // Aguardar todos os jobs completarem
                        this.extractedPages = await Promise.all(jobs);

                        // Ordenar p√°ginas por n√∫mero
                        this.extractedPages.sort((a, b) => a.pageNum - b.pageNum);

                        // Limpar workers
                        await scheduler.terminate();

                        // Compilar resultados
                        this.compileResults();
                        this.processingTime = ((Date.now() - startTime) / 1000).toFixed(1);

                        // FASE 2: Salvar no cache
                        this.saveToCache(cacheKey, {
                            pages: this.extractedPages,
                            timestamp: Date.now()
                        });

                        this.ocrCompleted = true;
                        this.processing = false;
                        this.progress = 100;
                        this.showMessage(`‚úÖ OCR conclu√≠do! ${this.totalPages} p√°ginas em ${this.processingTime}s (${this.performanceMetrics.pagesPerSecond} p√°g/s)`, 'success');

                    } catch (error) {
                        console.error('OCR Error:', error);
                        this.processing = false;
                        this.showMessage('Erro no processamento OCR: ' + error.message, 'error');
                    }
                },

                // FASE 2: Sistema de Cache
                loadFromCache(key) {
                    try {
                        const cached = localStorage.getItem(key);
                        if (!cached) return null;

                        const data = JSON.parse(cached);
                        const age = Date.now() - data.timestamp;
                        const maxAge = 24 * 60 * 60 * 1000; // 24 horas

                        if (age > maxAge) {
                            localStorage.removeItem(key);
                            return null;
                        }

                        return data;
                    } catch (e) {
                        return null;
                    }
                },

                saveToCache(key, data) {
                    try {
                        localStorage.setItem(key, JSON.stringify(data));
                    } catch (e) {
                        console.warn('N√£o foi poss√≠vel salvar no cache:', e);
                    }
                },

                // ======= MELHORIAS DE QUALIDADE E VELOCIDADE =======

                // MELHORIA 1: Detec√ß√£o de Texto Nativo (VELOCIDADE ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê)
                async checkNativeText(pageNum) {
                    try {
                        const page = await this.pdfDocument.getPage(pageNum);
                        const textContent = await page.getTextContent();
                        const text = textContent.items.map(item => item.str).join(' ').trim();

                        // Se a p√°gina tem mais de 50 caracteres de texto nativo, n√£o precisa OCR
                        return text.length > 50 ? text : null;
                    } catch (e) {
                        return null;
                    }
                },

                // MELHORIA 2: Binariza√ß√£o Adaptativa com Otsu (QUALIDADE ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê)
                applyOtsuBinarization(imageData) {
                    const data = imageData.data;
                    const len = data.length;

                    // Converter para grayscale
                    const grayPixels = [];
                    for (let i = 0; i < len; i += 4) {
                        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                        grayPixels.push(gray);
                    }

                    // Calcular histograma
                    const histogram = new Array(256).fill(0);
                    for (const gray of grayPixels) {
                        histogram[Math.floor(gray)]++;
                    }

                    // M√©todo de Otsu para encontrar threshold ideal
                    const total = grayPixels.length;
                    let sum = 0;
                    for (let i = 0; i < 256; i++) {
                        sum += i * histogram[i];
                    }

                    let sumB = 0;
                    let wB = 0;
                    let wF = 0;
                    let maxVariance = 0;
                    let threshold = 0;

                    for (let i = 0; i < 256; i++) {
                        wB += histogram[i];
                        if (wB === 0) continue;

                        wF = total - wB;
                        if (wF === 0) break;

                        sumB += i * histogram[i];
                        const mB = sumB / wB;
                        const mF = (sum - sumB) / wF;
                        const variance = wB * wF * (mB - mF) * (mB - mF);

                        if (variance > maxVariance) {
                            maxVariance = variance;
                            threshold = i;
                        }
                    }

                    // Aplicar threshold encontrado
                    for (let i = 0, j = 0; i < len; i += 4, j++) {
                        const binary = grayPixels[j] > threshold ? 255 : 0;
                        data[i] = data[i + 1] = data[i + 2] = binary;
                    }

                    return imageData;
                },

                // MELHORIA 3: Remo√ß√£o de Ru√≠do Avan√ßada (QUALIDADE ‚≠ê‚≠ê‚≠ê‚≠ê)
                removeNoiseAdvanced(imageData) {
                    const data = imageData.data;
                    const width = imageData.width;
                    const height = imageData.height;

                    // Filtro de mediana 3x3 (remove ru√≠do salt-and-pepper)
                    const output = new Uint8ClampedArray(data);

                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const neighbors = [];

                            // Coletar vizinhos 3x3
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const idx = ((y + dy) * width + (x + dx)) * 4;
                                    neighbors.push(data[idx]);
                                }
                            }

                            // Mediana
                            neighbors.sort((a, b) => a - b);
                            const median = neighbors[4];

                            const idx = (y * width + x) * 4;
                            output[idx] = output[idx + 1] = output[idx + 2] = median;
                        }
                    }

                    // Copiar de volta
                    for (let i = 0; i < data.length; i++) {
                        data[i] = output[i];
                    }

                    return imageData;
                },

                // MELHORIA 4: Detec√ß√£o e Corre√ß√£o de Orienta√ß√£o (QUALIDADE ‚≠ê‚≠ê‚≠ê‚≠ê)
                async detectAndCorrectOrientation(canvas) {
                    // Criar worker tempor√°rio apenas para detectar orienta√ß√£o
                    const detector = await Tesseract.createWorker(this.ocrLanguage, 1, {
                        logger: () => {} // Silenciar
                    });

                    const result = await detector.recognize(canvas);
                    const orientation = result.data.orientation;

                    await detector.terminate();

                    // Se rota√ß√£o detectada, corrigir
                    if (orientation && orientation.confidence > 0.5 && orientation.degrees !== 0) {
                        const rotated = document.createElement('canvas');
                        const ctx = rotated.getContext('2d');

                        if (orientation.degrees === 90 || orientation.degrees === 270) {
                            rotated.width = canvas.height;
                            rotated.height = canvas.width;
                        } else {
                            rotated.width = canvas.width;
                            rotated.height = canvas.height;
                        }

                        ctx.translate(rotated.width / 2, rotated.height / 2);
                        ctx.rotate((orientation.degrees * Math.PI) / 180);
                        ctx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);

                        return rotated;
                    }

                    return canvas;
                },

                // MELHORIA 5: P√≥s-processamento de Texto (QUALIDADE ‚≠ê‚≠ê‚≠ê)
                postProcessText(text) {
                    if (!text) return text;

                    // Corre√ß√µes comuns de OCR em portugu√™s
                    const corrections = {
                        // Confus√µes comuns
                        'rn': 'm',     // "bem" lido como "bern"
                        '|': 'l',      // pipe confundido com L
                        '0': 'o',      // zero confundido com O (em palavras)
                        '1': 'l',      // um confundido com l (em palavras)
                        '5': 's',      // cinco confundido com S
                        // Espa√ßamentos
                        /\s+/g: ' ',   // m√∫ltiplos espa√ßos
                        /\n{3,}/g: '\n\n', // m√∫ltiplas linhas vazias
                    };

                    let processed = text;

                    // Aplicar corre√ß√µes em contexto de palavras
                    processed = processed.replace(/([a-z])0([a-z])/gi, '$1o$2'); // o em palavras
                    processed = processed.replace(/([a-z])1([a-z])/gi, '$1l$2'); // l em palavras
                    processed = processed.replace(/\s+/g, ' '); // espa√ßos m√∫ltiplos
                    processed = processed.replace(/\n{3,}/g, '\n\n'); // linhas m√∫ltiplas

                    // Remover espa√ßos antes de pontua√ß√£o
                    processed = processed.replace(/\s+([.,;:!?])/g, '$1');

                    // Capitalizar ap√≥s pontos
                    processed = processed.replace(/\.\s+([a-z])/g, (match, letter) =>
                        '. ' + letter.toUpperCase()
                    );

                    return processed.trim();
                },

                // MELHORIA 6: Par√¢metros Otimizados por Modo
                getOptimizedTesseractParams() {
                    const baseParams = {
                        tessedit_pageseg_mode: this.preserveLayout ? '3' : '6',
                        preserve_interword_spaces: '1',
                    };

                    if (this.ocrMode === 'fast') {
                        // Modo Turbo: sacrifica um pouco de qualidade por velocidade
                        return {
                            ...baseParams,
                            tessedit_ocr_engine_mode: '3', // Fast neural net
                            tessedit_pageseg_mode: '6',    // Bloco uniforme
                            edges_max_children_per_outline: '10',
                        };
                    } else if (this.ocrMode === 'accurate') {
                        // Modo Balanceado: melhor custo-benef√≠cio
                        return {
                            ...baseParams,
                            tessedit_ocr_engine_mode: '1', // LSTM only
                            textord_heavy_nr: '1',         // Remo√ß√£o de ru√≠do
                        };
                    } else if (this.ocrMode === 'best') {
                        // Modo M√°xima Qualidade: todas as otimiza√ß√µes
                        return {
                            ...baseParams,
                            tessedit_ocr_engine_mode: '1',
                            tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Ä√Å√Ç√É√Ñ√á√à√â√ä√ã√å√ç√é√è√í√ì√î√ï√ñ√ô√ö√õ√ú√†√°√¢√£√§√ß√®√©√™√´√¨√≠√Æ√Ø√≤√≥√¥√µ√∂√π√∫√ª√º .,;:!?-/()"\'',
                            textord_heavy_nr: '1',
                            classify_bln_numeric_mode: '0',
                        };
                    }

                    return baseParams;
                },

                // MELHORIA 7: Pr√©-processamento Completo e Otimizado
                async enhanceImageAdvanced(canvas) {
                    if (!this.enhanceImage) return canvas;

                    const context = canvas.getContext('2d');
                    let imageData = context.getImageData(0, 0, canvas.width, canvas.height);

                    // 1. Remover ru√≠do primeiro
                    imageData = this.removeNoiseAdvanced(imageData);

                    // 2. Aplicar binariza√ß√£o adaptativa (Otsu)
                    imageData = this.applyOtsuBinarization(imageData);

                    // 3. Aplicar sharpening leve
                    const sharpened = this.applySharpen(imageData);

                    context.putImageData(sharpened, 0, 0);

                    return canvas;
                },

                applySharpen(imageData) {
                    // Kernel de sharpening
                    const kernel = [
                        0, -1, 0,
                        -1, 5, -1,
                        0, -1, 0
                    ];

                    return this.applyConvolution(imageData, kernel);
                },

                applyConvolution(imageData, kernel) {
                    const data = imageData.data;
                    const width = imageData.width;
                    const height = imageData.height;
                    const output = new Uint8ClampedArray(data);

                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            let sum = 0;

                            for (let ky = 0; ky < 3; ky++) {
                                for (let kx = 0; kx < 3; kx++) {
                                    const idx = ((y + ky - 1) * width + (x + kx - 1)) * 4;
                                    sum += data[idx] * kernel[ky * 3 + kx];
                                }
                            }

                            const idx = (y * width + x) * 4;
                            const value = Math.max(0, Math.min(255, sum));
                            output[idx] = output[idx + 1] = output[idx + 2] = value;
                        }
                    }

                    // Criar novo ImageData e copiar dados processados
                    const result = new ImageData(width, height);
                    result.data.set(output);
                    return result;
                },

                getTesseractParams() {
                    const params = {
                        tessedit_pageseg_mode: this.preserveLayout ? '3' : '6',
                        preserve_interword_spaces: '1'
                    };
                    
                    if (this.ocrMode === 'fast') {
                        params.tessedit_ocr_engine_mode = '3';
                    } else if (this.ocrMode === 'best') {
                        params.tessedit_ocr_engine_mode = '1';
                        params.tessedit_char_whitelist = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Ä√Å√Ç√É√Ñ√á√à√â√ä√ã√å√ç√é√è√í√ì√î√ï√ñ√ô√ö√õ√ú√†√°√¢√£√§√ß√®√©√™√´√¨√≠√Æ√Ø√≤√≥√¥√µ√∂√π√∫√ª√º .,;:!?-/()"\'';
                    }
                    
                    return params;
                },
                
                enhanceImageQuality(context, width, height) {
                    // Aplicar filtros para melhorar a qualidade da imagem
                    const imageData = context.getImageData(0, 0, width, height);
                    const data = imageData.data;
                    
                    // Aumentar contraste
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = this.adjustContrast(data[i], 1.5);     // Red
                        data[i + 1] = this.adjustContrast(data[i + 1], 1.5); // Green
                        data[i + 2] = this.adjustContrast(data[i + 2], 1.5); // Blue
                    }
                    
                    // Binariza√ß√£o (preto e branco)
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                        const binary = gray > 128 ? 255 : 0;
                        data[i] = data[i + 1] = data[i + 2] = binary;
                    }
                    
                    context.putImageData(imageData, 0, 0);
                },
                
                adjustContrast(value, contrast) {
                    return ((value / 255 - 0.5) * contrast + 0.5) * 255;
                },
                
                compileResults() {
                    // Compilar texto de todas as p√°ginas
                    this.extractedText = this.extractedPages
                        .map(p => `--- P√°gina ${p.pageNum} ---\n${p.text}`)
                        .join('\n\n');
                    
                    // Calcular estat√≠sticas
                    const totalConfidence = this.extractedPages.reduce((sum, p) => sum + p.confidence, 0);
                    this.averageConfidence = totalConfidence / this.extractedPages.length;
                    
                    this.wordCount = this.extractedText.split(/\s+/).filter(word => word.length > 0).length;
                },
                
                async downloadSearchablePDF() {
                    try {
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF();
                        
                        // Adicionar cada p√°gina com texto invis√≠vel (searchable)
                        for (let i = 0; i < this.extractedPages.length; i++) {
                            if (i > 0) pdf.addPage();
                            
                            // Renderizar imagem da p√°gina original
                            const page = await this.pdfDocument.getPage(i + 1);
                            const viewport = page.getViewport({ scale: 2 });
                            
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            
                            await page.render({
                                canvasContext: context,
                                viewport: viewport
                            }).promise;
                            
                            // Adicionar imagem ao PDF
                            const imgData = canvas.toDataURL('image/jpeg', 0.95);
                            pdf.addImage(imgData, 'JPEG', 0, 0, 210, 297);
                            
                            // Adicionar texto invis√≠vel para tornar pesquis√°vel
                            pdf.setTextColor(255, 255, 255);
                            pdf.setFontSize(1);
                            
                            const lines = this.extractedPages[i].text.split('\n');
                            let y = 10;
                            for (const line of lines) {
                                if (line.trim()) {
                                    pdf.text(line, 10, y);
                                    y += 5;
                                    if (y > 280) break;
                                }
                            }
                        }
                        
                        // Salvar PDF
                        const fileName = this.pdfFile.name.replace('.pdf', '_OCR.pdf');
                        pdf.save(fileName);
                        
                        this.showMessage('PDF pesquis√°vel baixado com sucesso!', 'success');
                    } catch (error) {
                        this.showMessage('Erro ao gerar PDF: ' + error.message, 'error');
                    }
                },
                
                downloadText() {
                    const blob = new Blob([this.extractedText], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.pdfFile.name.replace('.pdf', '_texto.txt');
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.showMessage('Texto extra√≠do baixado com sucesso!', 'success');
                },
                
                resetApp() {
                    this.pdfFile = null;
                    this.pdfDocument = null;
                    this.currentPage = 1;
                    this.totalPages = 0;
                    this.extractedText = '';
                    this.extractedPages = [];
                    this.ocrCompleted = false;
                    this.averageConfidence = 0;
                    this.wordCount = 0;
                    this.processingTime = 0;
                    this.$refs.fileInput.value = '';
                },
                
                showMessage(message, color = 'success') {
                    this.snackbarMessage = message;
                    this.snackbarColor = color;
                    this.snackbar = true;
                }
            }
        }).use(vuetify).mount('#app');
    </script>
</body>
</html>